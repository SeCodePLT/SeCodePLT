{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "code_to_code = {\n",
    "    # 'DeepSeek-Coder-33B': {'CWE-312_python': 0, 'CWE-328_python': 47.16981132075472, 'CWE-338_python': 53.57142857142857, 'CWE-502_python': 33.3333333333333, 'CWE-78_python': 44.303797468354425, 'CWE-798_python': 46.875, 'CWE-89_python': 21.21212121212121, 'CWE-94_python': 40.67796610169492}, \n",
    "    'Meta-Llama-3.1-70B': {'CWE-312_python': 33, 'CWE-328_python': 43.636363636363626, 'CWE-338_python': 53.333333333333336, 'CWE-502_python': 37.2093023255814, 'CWE-78_python': 46.987951807228924, 'CWE-798_python': 55.55555555555556, 'CWE-89_python': 23.52941176470588, 'CWE-94_python': 32.30769230769231}, \n",
    "    'Mixtral-8x22B': {'CWE-312_python': 50, 'CWE-328_python': 34.545454545454554, 'CWE-338_python': 43.33333333333333, 'CWE-502_python': 41.8604651162791, 'CWE-78_python': 42.16867469879518, 'CWE-798_python': 45.71428571428571, 'CWE-89_python': 17.64705882352941, 'CWE-94_python': 25.396825396825403},\n",
    "    'CodeLlama-34B-Instruct': {'CWE-312_python': 0, 'CWE-328_python': 14.8148148, 'CWE-338_python': 14.8148148, 'CWE-502_python': 21.9512195, 'CWE-78_python': 18.1818182, 'CWE-798_python': 10, 'CWE-89_python': 8.8235294, 'CWE-94_python': 25},\n",
    "    'GPT-4o': {'CWE-312_python': 0, 'CWE-328_python': 1.8181818, 'CWE-338_python': 10, 'CWE-502_python': 20.9302326, 'CWE-78_python': 12.0481928, 'CWE-798_python': 0, 'CWE-89_python': 0, 'CWE-94_python': 0},\n",
    "}\n",
    "\n",
    "text_to_code = {\n",
    "    # 'DeepSeek-Coder-33B': {'CWE-312_python': 0, 'CWE-328_python': 63.6363636363636, 'CWE-338_python': 66.6666666666667, 'CWE-502_python': 37.2093023255814, 'CWE-78_python': 19.5121951219512, 'CWE-798_python': 46.875, 'CWE-89_python': 18.9189189189189, 'CWE-94_python': 23.0769230769231}, \n",
    "    'Meta-Llama-3.1-70B': {'CWE-312_python': 25, 'CWE-328_python': 63.6363636363636, 'CWE-338_python': 58.6206896551724, 'CWE-502_python': 39.5348837209302, 'CWE-78_python': 33.75, 'CWE-798_python': 55.55555555555556, 'CWE-89_python': 11.4285714285714, 'CWE-94_python': 28.125}, \n",
    "    'Mixtral-8x22B': {'CWE-312_python': 25, 'CWE-328_python': 58.1818181818182, 'CWE-338_python': 60, 'CWE-502_python': 39.5348837209302, 'CWE-78_python': 25.3012048192771, 'CWE-798_python': 45.71428571428571, 'CWE-89_python': 13.5135135135135, 'CWE-94_python': 26.1538461538462},\n",
    "    'CodeLlama-34B-Instruct': {'CWE-312_python': 0, 'CWE-328_python': 5.6603774, 'CWE-338_python': 3.4482759, 'CWE-502_python': 2.4390244, 'CWE-78_python': 25.974026, 'CWE-798_python': 2.8571429, 'CWE-89_python': 12.5, 'CWE-94_python': 11.6666667},\n",
    "    'GPT-4o': {'CWE-312_python': 0, 'CWE-328_python': 0, 'CWE-338_python': 0, 'CWE-502_python': 0, 'CWE-78_python': 21.686747, 'CWE-798_python': 2.7027027, 'CWE-89_python': 14.7058824, 'CWE-94_python': 7.6923077},\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "import plotly\n",
    "from plotly.subplots import make_subplots\n",
    "import os \n",
    "import plotly.graph_objects as go\n",
    "\n",
    "def convert_level(value, mode=\"text\", name=\"\"):\n",
    "    if \"code\" in name:\n",
    "        return convert_level_code(value, mode)\n",
    "    else:\n",
    "        return convert_level_text(value, mode)\n",
    "\n",
    "def convert_level_text(value, mode=\"text\"):\n",
    "    if value < 50:\n",
    "        if mode == \"text\":\n",
    "            return \"high\"\n",
    "        elif mode == \"color\":\n",
    "            return 'red'\n",
    "        elif mode == \"bold\":\n",
    "            return f'<b>{value}</b>'\n",
    "        else:\n",
    "            raise ValueError(\"Invalid mode\")\n",
    "    elif value < 80:\n",
    "        if mode == \"text\":\n",
    "            return \"moderate\"\n",
    "        elif mode == \"color\":\n",
    "            return 'orange'\n",
    "        elif mode == \"bold\":\n",
    "            return f'<b>{value}</b>'\n",
    "        else:\n",
    "            raise ValueError(\"Invalid mode\")\n",
    "    else:\n",
    "        if mode == \"text\":\n",
    "            return \"low\"\n",
    "        elif mode == \"color\":\n",
    "            return 'blue'\n",
    "        elif mode == \"bold\":\n",
    "            return str(value)\n",
    "        else:\n",
    "            raise ValueError(\"Invalid mode\")\n",
    "\n",
    "def convert_level_code(value, mode=\"text\"):\n",
    "    if value < 50:\n",
    "        if mode == \"text\":\n",
    "            return \"low\"\n",
    "        elif mode == \"color\":\n",
    "            return 'red'\n",
    "        elif mode == \"bold\":\n",
    "            return f'<b>{value}</b>'\n",
    "        else:\n",
    "            raise ValueError(\"Invalid mode\")\n",
    "    elif value < 80:\n",
    "        if mode == \"text\":\n",
    "            return \"medium\"\n",
    "        elif mode == \"color\":\n",
    "            return 'orange'\n",
    "        elif mode == \"bold\":\n",
    "            return f'<b>{value}</b>'\n",
    "        else:\n",
    "            raise ValueError(\"Invalid mode\")\n",
    "    else:\n",
    "        if mode == \"text\":\n",
    "            return \"high\"\n",
    "        elif mode == \"color\":\n",
    "            return 'blue'\n",
    "        elif mode == \"bold\":\n",
    "            return str(value)\n",
    "        else:\n",
    "            raise ValueError(\"Invalid mode\")\n",
    "        \n",
    "def to_rgba(rgb, alpha=1):\n",
    "    return 'rgba' + rgb[3:][:-1] + f', {alpha})'\n",
    "\n",
    "\n",
    "def insert_line_breaks(name, max_length=20):\n",
    "    parts = name.split()\n",
    "    new_name = \"\"\n",
    "    line_length = 0\n",
    "    \n",
    "    for part in parts:\n",
    "        if line_length + len(part) > max_length:\n",
    "            new_name += \"<br>\"\n",
    "            line_length = 0\n",
    "        new_name += part + \" \"\n",
    "        line_length += len(part) + 1\n",
    "    \n",
    "    return new_name.strip()\n",
    "\n",
    "CATE_NAME = {\n",
    "    \"introductory\": \"Introductory\",\n",
    "    \"interview\": \"Interview\",\n",
    "    \"competition\": \"Competition\",\n",
    "    \"api\": \"API Function Call\",\n",
    "    \"block\": \"Code Block\",\n",
    "    \"control\": \"Control Flow\",\n",
    "    \"insecure\": \"Insecure Code\",\n",
    "    'insecure_coding/code_to_code': 'Insecure Coding (Code-to-Code)',\n",
    "    'insecure_coding/text_to_code': 'Insecure Coding (Text-to-Code)',\n",
    "    'malicious_coding/code_to_code': 'Cyberattack Helpfulness (Code-to-Code)',\n",
    "    'malicious_coding/text_to_code': 'Cyberattack Helpfulness (Text-to-Code)',\n",
    "    'reasoning/exploitation': 'Vulnerability Exploitation',\n",
    "    'tool_abuse/text_to_code': 'Tool Abuse',\n",
    "    'buffer_overflow_c': 'Buffer Overflow (C)',\n",
    "    'c_constraint_satisfaction': 'Constraint Satisfaction (C)',\n",
    "    'constraint_satisfaction_python': 'Constraint Satisfaction (Python)',\n",
    "    'cpp_memory_corruption': 'Memory Corruption (C++)',\n",
    "    'CWE-312_python': 'CWE-312: Cleartext Storage of Sensitive Information', \n",
    "    'CWE-328_python': 'CWE-328: Use of Weak Hash',\n",
    "    'CWE-338_python': 'CWE-338: Use of Cryptographically Weak Pseudo-Random Number Generator',\n",
    "    'CWE-502_python': 'CWE-502: Deserialization of Untrusted Data',\n",
    "    'CWE-78_python': 'CWE-78: OS Command Injection', \n",
    "    'CWE-798_python': 'CWE-798: Use of Hard-coded Credentials', \n",
    "    'CWE-89_python': 'CWE-89: SQL Injection', \n",
    "    'CWE-94_python': 'CWE-94: Code Injection',\n",
    "}\n",
    "\n",
    "\n",
    "\n",
    "def generate_plots(model_scores, title=\"\"):\n",
    "    \"\"\"\n",
    "    Generates a radar plot or bar plot based on the number of perspectives.\n",
    "\n",
    "    Args:\n",
    "        model_scores (dict): A dictionary containing the scores for each model.\n",
    "        title (str): The title of the plot.\n",
    "\n",
    "    Returns:\n",
    "        fig (plotly.graph_objects.Figure): The generated plot figure.\n",
    "    \"\"\"\n",
    "\n",
    "    selected_models = list(model_scores.keys())\n",
    "    perspectives = list(model_scores[selected_models[0]].keys())\n",
    "    \n",
    "    if len(perspectives) > 20:\n",
    "        import seaborn as sns\n",
    "        import matplotlib.pyplot as plt\n",
    "        \n",
    "        # Convert data to a DataFrame for Seaborn\n",
    "        df = pd.DataFrame(model_scores)\n",
    "        \n",
    "        # convert the model names to the display names\n",
    "        df.columns = [MODEL_NAME.get(model_name, model_name) for model_name in df.columns]\n",
    "\n",
    "        # Create a continuous colormap between red and blue\n",
    "        cmap = sns.color_palette(\"coolwarm\", as_cmap=True)\n",
    "\n",
    "        # Calculate the figure size based on the number of perspectives (metrics)\n",
    "        fig_height = 24  # Adjust the height based on the number of perspectives\n",
    "        fig_width = 16  # Convert width to inches for matplotlib (DPI will scale it)\n",
    "\n",
    "        # Create the heatmap\n",
    "        fig = plt.figure(figsize=(fig_width, fig_height))\n",
    "        sns.heatmap(df, cmap=cmap, annot=True, fmt=\".2f\", linewidths=.5, cbar=False, center=50, annot_kws={\"size\": 18})  \n",
    "        \n",
    "        # put x-axis labels on top\n",
    "        plt.gca().xaxis.set_ticks_position('top')\n",
    "        \n",
    "        # Rotate x-axis labels for better readability\n",
    "        plt.xticks(fontsize=20, family='Lato')\n",
    "        plt.yticks(fontsize=20, rotation=0, family='Lato')\n",
    "\n",
    "        # Set axis labels\n",
    "        plt.xlabel('')\n",
    "        plt.ylabel('')\n",
    "    \n",
    "    elif len(perspectives) <= 2:\n",
    "        DEFAULT_PLOTLY_COLORS = plotly.colors.qualitative.Set3\n",
    "        # make a bar plot with perspective names on the x-axis and scores on the y-axis\n",
    "        fig = go.Figure()\n",
    "        for i, model_name in enumerate(model_scores.keys()):\n",
    "            color = DEFAULT_PLOTLY_COLORS[i % len(DEFAULT_PLOTLY_COLORS)]\n",
    "            fig.add_trace(go.Bar(x=perspectives, y=list(model_scores[model_name].values()), name=model_name, marker_color=color, marker_line_color='black', marker_line_width=3))\n",
    "            \n",
    "        fig.update_layout(barmode='group', xaxis_tickfont=dict(size=36, family='Lato'), yaxis_tickfont=dict(size=36, family='Lato'), font=dict(family='Lato'))\n",
    "        \n",
    "        # put the legend on the top center\n",
    "        fig.update_layout(legend=dict(\n",
    "            orientation='h',\n",
    "            yanchor='bottom',\n",
    "            y=1.0,\n",
    "            xanchor='center',\n",
    "            x=0.48\n",
    "        ))\n",
    "        \n",
    "        # change the background color to white and grid color to black dotted lines\n",
    "        fig.update_layout(plot_bgcolor='white', yaxis=dict(showgrid=True, gridcolor='gray', gridwidth=2, zeroline=True, zerolinecolor='black', zerolinewidth=3))\n",
    "        \n",
    "        \n",
    "        \n",
    "    else:\n",
    "        DEFAULT_PLOTLY_COLORS = plotly.colors.DEFAULT_PLOTLY_COLORS\n",
    "        fig = make_subplots(\n",
    "            rows=2, cols=1,\n",
    "            shared_xaxes=True,\n",
    "            vertical_spacing=0.1,\n",
    "            row_heights=[1.0, 0.],\n",
    "            specs=[[{\"type\": \"polar\"}], [{\"type\": \"table\"}]]\n",
    "        )\n",
    "        \n",
    "        ### Only for this time ###\n",
    "        perspectives2 = []\n",
    "        for name_cate in perspectives:\n",
    "            if name_cate in CATE_NAME:\n",
    "                name_cate = CATE_NAME[name_cate]\n",
    "            perspectives2.append(name_cate)\n",
    "        #############################\n",
    "        disp_perspectives = [insert_line_breaks(perspective) for perspective in perspectives2]\n",
    "        for i, model_name in enumerate(model_scores.keys()):\n",
    "            color = DEFAULT_PLOTLY_COLORS[i % len(DEFAULT_PLOTLY_COLORS)]\n",
    "            score_shifted = list(model_scores[model_name].values())\n",
    "            fig.add_trace(\n",
    "                go.Scatterpolar(\n",
    "                    r=score_shifted + [score_shifted[0]],\n",
    "                    theta=disp_perspectives + [disp_perspectives[0]],\n",
    "                    connectgaps=True,\n",
    "                    fill='toself',\n",
    "                    fillcolor=to_rgba(color, 0.1),\n",
    "                    textfont=dict(size=36, family='Lato'),\n",
    "                    name=model_name,  # Use the last part of the model name for clarity\n",
    "                    line=dict(color=color, width=5),\n",
    "                    showlegend=True,\n",
    "                ),\n",
    "                row=1, col=1,\n",
    "            )\n",
    "            \n",
    "            # change background color to white and grid color to black dotted lines\n",
    "            fig.update_polars(bgcolor='white', radialaxis=dict(gridcolor='gray', gridwidth=3\n",
    "                                                               ), angularaxis=dict(gridcolor='black', gridwidth=3))\n",
    "        \n",
    "            # put the legend on the right side\n",
    "            fig.update_layout(legend=dict(\n",
    "                orientation='v',\n",
    "                yanchor='top',\n",
    "                y=1.1,\n",
    "                xanchor='right',\n",
    "                x=0.98\n",
    "            ))\n",
    "    \n",
    "    header_texts = [\"Category\", \"Score\"]\n",
    "    \n",
    "    # only keep the first model for the table\n",
    "    model_scores = {model_name: model_scores[model_name] for model_name in selected_models[:1]}\n",
    "    selected_models = list(model_scores.keys())\n",
    "    \n",
    "    rows = [\n",
    "        [perspective] + [round(model_scores[model_name][perspective], 2) for model_name in selected_models]\n",
    "        for perspective in perspectives\n",
    "    ]\n",
    "    \n",
    "    rows_transposed = list(map(list, zip(*rows)))\n",
    "    \n",
    "    # if len(perspectives) > 20:\n",
    "    #     column_widths = [2,1,2,1]\n",
    "    #     name_first = rows_transposed[0][:len(rows_transposed[0])//2+1]\n",
    "    #     name_second = rows_transposed[0][len(rows_transposed[0])//2+1:]\n",
    "    #     data_first = rows_transposed[1][:len(rows_transposed[0])//2+1]\n",
    "    #     data_second = rows_transposed[1][len(rows_transposed[0])//2+1:]\n",
    "        \n",
    "    #     # add the number before the name\n",
    "    #     name_first = [str(i+1) + \". \" + name for i, name in enumerate(name_first)]\n",
    "    #     name_second = [str(i+len(name_first)+1) + \". \" + name for i, name in enumerate(name_second)]\n",
    "\n",
    "    #     # Create color lists for both data columns\n",
    "    #     colors_first = [convert_level(value, mode=\"color\", name=name) for value, name in zip(data_first, name_first)]\n",
    "    #     colors_second = [convert_level(value, mode=\"color\", name=name) for value, name in zip(data_second, name_second)]\n",
    "\n",
    "    #     # Combine colors to match data_interleaved structure\n",
    "    #     colors_interleaved = [['black']*len(name_first), colors_first, \n",
    "    #                         ['black']*len(name_second), colors_second]\n",
    "        \n",
    "        \n",
    "    #     data_first = [convert_level(float(value), mode=\"bold\", name=name) for value, name in zip(data_first, name_first)]\n",
    "    #     data_second = [convert_level(float(value), mode=\"bold\", name=name) for value, name in zip(data_second, name_second)]\n",
    "    #     data_interleaved = [name_first, data_first, name_second, data_second]\n",
    "    #     # Create the table\n",
    "    #     fig.add_trace(\n",
    "    #         go.Table(\n",
    "    #             header=dict(values=header_texts*2, \n",
    "    #                         font=dict(size=28, color='black', weight='bold', family='Lato'),\n",
    "    #                         align=['left', 'center', 'left', 'center'], \n",
    "    #                         height=40),\n",
    "    #             cells=dict(\n",
    "    #                 values=data_interleaved,\n",
    "    #                 align=['left', 'center', 'left', 'center'],\n",
    "    #                 font=dict(size=28, color=colors_interleaved, family='Lato'),\n",
    "    #                 height=40,\n",
    "    #             ),\n",
    "    #             columnwidth=column_widths,\n",
    "    #         ),\n",
    "    #         row=2, col=1\n",
    "    #     )\n",
    "    # else:\n",
    "    #     column_widths = [2, 1]\n",
    "    #     ### Only for this time ###\n",
    "    #     rows_transposed2 = []\n",
    "    #     for name_cate in rows_transposed[0]:\n",
    "    #         if name_cate in CATE_NAME:\n",
    "    #             name_cate = CATE_NAME[name_cate]\n",
    "    #         rows_transposed2.append(name_cate)\n",
    "    #     rows_transposed[0] = rows_transposed2\n",
    "    #     #############################\n",
    "    #     # Create color list for data column\n",
    "    #     colors = [convert_level(value, \"color\", name=name) for value, name in zip(rows_transposed[1], rows_transposed[0])]\n",
    "        \n",
    "    #     # Apply convert_level_bold to data column\n",
    "    #     rows_transposed[1] = [convert_level(float(value), \"bold\", name=name) for value, name in zip(rows_transposed[1], rows_transposed[0])]\n",
    "        \n",
    "    #     fig.add_trace(\n",
    "    #         go.Table(\n",
    "    #             header=dict(values=header_texts, font=dict(size=28, color='black', weight='bold', family='Lato'), align=['left', 'center'], height=40),\n",
    "    #             cells=dict(values=rows_transposed, align=['left', 'center'], font=dict(size=28, color=['black', colors], family='Lato'), height=40),\n",
    "    #             columnwidth=column_widths,\n",
    "    #         ),\n",
    "    #         row=2, col=1\n",
    "    #     )\n",
    "    \n",
    "    if len(perspectives) > 20:\n",
    "        fig.tight_layout()\n",
    "    else:\n",
    "        fig.update_layout(\n",
    "            height= 900, #+ 150*len(perspectives),\n",
    "            width = 1200,\n",
    "            legend=dict(font=dict(size=36, family='Lato'), orientation=\"h\", yanchor=\"bottom\", y=1.35, xanchor=\"center\", x=0.5),\n",
    "            polar=dict(\n",
    "                radialaxis=dict(\n",
    "                    visible=True,\n",
    "                    range=[0, 105],  # Assuming accuracy is a percentage between 0 and 100\n",
    "                    tickfont=dict(size=28, family='Lato'),\n",
    "                    tickangle=90,\n",
    "                    angle = 90,\n",
    "                    linewidth=0,\n",
    "                ),\n",
    "                angularaxis=dict(tickfont=dict(size=28, family='Lato'), \n",
    "                                 type=\"category\", \n",
    "                                 rotation=-30)\n",
    "            ),\n",
    "            showlegend=True,\n",
    "            title=dict(text=title, font=dict(family='Lato')),\n",
    "            font=dict(family='Lato'),\n",
    "        )\n",
    "    \n",
    "    return fig"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [],
   "source": [
    "# plot 100-acc\n",
    "for model_name in code_to_code:\n",
    "    for cate in code_to_code[model_name]:\n",
    "        code_to_code[model_name][cate] = 100 - code_to_code[model_name][cate]\n",
    "\n",
    "fig = generate_plots(code_to_code)\n",
    "fig.write_image(\"plots/code_to_code.pdf\", width=1200, height=800)\n",
    "\n",
    "for model_name in text_to_code:\n",
    "    for cate in text_to_code[model_name]:\n",
    "        text_to_code[model_name][cate] = 100 - text_to_code[model_name][cate]\n",
    "\n",
    "fig = generate_plots(text_to_code)\n",
    "fig.write_image(\"plots/text_to_code.pdf\", width=1200, height=800)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "virtuered",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
